# Day 8

## Solution of puzzle 1
Problem: http://adventofcode.com/2017/day/8

Our main class is going to be AOC8, with a variable to store the instructions, and another one for the state of the registers.
```Smalltalk
Object subclass: #AOC8
	instanceVariableNames: 'instructions registers'
	classVariableNames: ''
	package: 'AOC8'
```

We create a function to get the raw data (the following snippet only features the first lines for concision purposes).
```Smalltalk
AOC8>>#rawData
	^ 'utc dec -736 if p > -7
tn inc -876 if qlm == 4
uz dec 294 if l < 10
...
```

We create an Instruction class with appropriate instance variables and accessors to represent CPU instructions.
```Smalltalk
Object subclass: #Instruction
	instanceVariableNames: 'register operator operand conditionRegister conditionOperator conditionOperand'
	classVariableNames: ''
	package: 'AOC8'
```

We create a method to create instances of Instruction from the strings of individual instructions.
```Smalltalk
Instruction class>>#newFromInstructionString: aString
	| splitString instruction |
	splitString := (aString splitOn: ($ )) collect: #trimmed.
	instruction := self new.
	instruction register: (splitString at: 1).
	instruction operator: (splitString at: 2).
	instruction operand: (splitString at: 3).
	instruction conditionRegister: (splitString at: 5).
	instruction conditionOperator: (splitString at: 6).
	instruction conditionOperand: (splitString at: 7).
	^ instruction.
```

We create a function to convert the complete raw data into instances of Instruction.
```Smalltalk
AOC8>>#loadInstructions
	instructions := ((self rawData trimmed splitOn: Character cr) collect: #trimmed) collect: [:ins | Instruction newFromInstructionString: ins].
```

We create a class to handle the management of the registers, storing them in a Dictionary. Since we do not know the names of the registers in advance, they will be created on the fly as needed.
```Smalltalk
Object subclass: #RegisterManager
	instanceVariableNames: 'registers'
	classVariableNames: ''
	package: 'AOC8'
```
```Smalltalk
RegisterManager>>#initialize
	registers := Dictionary new.

RegisterManager>>#readRegisterNamed: aString
	^ registers at: aString ifAbsent: [ 0 ].

RegisterManager>>#writeRegisterNamed: aString withValue: aValue
	^ registers at: aString put: aValue.
```

Since the goal of the puzzle is to get the largest value in any register, we add a method to compute just that.
```Smalltalk
RegisterManager>>#largestRegisterValue
	| registerValues largestValue |
	registerValues := registers values.
	registerValues isEmpty ifTrue: [ self error: 'No registers' ] ifFalse:[
		largestValue := registerValues at: 1.
		registerValues do: [ :val | (val > largestValue) ifTrue: [ largestValue := val ]].
		^ largestValue.
	]
```

Going back to the Instruction class, we add the main method: `performInstruction`, that takes as input an instance of RegisterManager, checks the condition and based on the result perform or not the operation. We also add helper functions to evaluate the condition and compute the new value the register should take. All these functions pass themselves the registerManager as argument.
```Smalltalk
Instruction>>#performInstruction: aRegisterManager
	(self evaluateCondition: aRegisterManager) ifTrue: [ aRegisterManager writeRegisterNamed: self register withValue: (self newRegisterValue: aRegisterManager) ]

Instruction>>#evaluateCondition: aRegisterManager
	| registerValue operandValue |
	registerValue := aRegisterManager readRegisterNamed: self conditionRegister.
	operandValue := self conditionOperand asInteger.
	(self conditionOperator = '==') ifTrue: [ ^ registerValue == operandValue ].
	(self conditionOperator = '>') ifTrue: [ ^ registerValue > operandValue ].
	(self conditionOperator = '<') ifTrue: [ ^ registerValue < operandValue ].
	(self conditionOperator = '!=') ifTrue: [ ^ registerValue ~= operandValue ].
	(self conditionOperator = '>=') ifTrue: [ ^ registerValue >= operandValue ].
	(self conditionOperator = '<=') ifTrue: [ ^ registerValue <= operandValue ].
	self error: 'Unknown operator: ', self conditionOperator.

Instruction>>#newRegisterValue: aRegisterManager
	| currentValue operandValue |
	currentValue := aRegisterManager readRegisterNamed: self register.
	operandValue := self operand asInteger.
	(self operator = 'inc') ifTrue: [ ^ currentValue + operandValue].
	(self operator = 'dec') ifTrue: [ ^ currentValue - operandValue].
```

Finally, we write the `main` method, that instanciates an empty RegisterManager, converts the raw data into Instruction instances, apply all these instructions and returns the largest register value.
```Smalltalk
AOC8>>#main
	registers := RegisterManager new.
	self loadInstructions.
	instructions do: [ :ins | ins performInstruction: registers ].
	^ registers largestRegisterValue.
```

As a conclusion, the following code returns the solution to the puzzle: 6828.
```Smalltalk
AOC8 new main
```

## Solution of puzzle 2
Short description of the problem.

Code snippets for your solution and description of this code.


